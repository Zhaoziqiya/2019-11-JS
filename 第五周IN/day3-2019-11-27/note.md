- `匿名函数自执行输出结果是函数本身`
# 同步异步
- JS按理来说是从上往下解读代码的，它是单线程的（同一时间只能做一件事情）

        事件调用 -> 把任务交给了事件引擎

## 同步
- **代码从上往依次此执行，如果一个地方卡住了，下面代码不执行**
## 异步
- **虽然从上往下执行，如果一个地方卡住了，不会阻止代码执行**

    - 定时器、所有事件、promise

    - 异步的操作不容易进行维护发者的

    - `promise` 是解决异步编程的问题的（也就是说，让异步代码同步执行）


```
先执行主线程 -> 异步队列 -> 微任务 -> 宏任务

宏任务


微任务 -> 在异步队列里比宏任务先执行
```
# 事件循环
- js先执行主线程的代码，如果主线程有异步代码，比如定时器、promise或者事件那么会把异步代码放到异步队列中储存。
    - 当异步代码的条件成立的时候，把异步代码压入到主线程中执行，压入的方式是如果有微任务就先执行微任务，执行完微任务在执行宏任务
    -  当主线程空间的时候执行压入的代码，执行完之后再从异步队列中压入异步代码到主线程中

- 这个过程叫事件循环

> `注意的是执行完微任务是第一层的，如果在宏任务中开个微任务，那么闲执行宏任务，再执行宏任务的微任务`

```
    setTimeout(function(){
        promise()
    })

```

# promise
- **promise -> 承诺**

- 为什么要用promise?

    - promise解决了异步编程问题

    - 在then里面就走"同步"

- 如何使用promise?

```
    new Promise(function(resolve,reject){
        // 主线程
        // 当异步代码执行完，通过异步代码的结果去调用resolve或者reject

        // 异步代码有可能报错或者错误，如果报错或者错误就执行reject
        // 一般都是resolve(放异步的结果)
    });
    
    
```
>它有一个返回值，返回值是promise对象，这个对象有then方法then(成功函数，失败函数)

    第一个then （微任务）

        成功函数里面的参数就是异步的结果

    第二个then （微任务）

        第一个then的返回值

```
    let p = new Promise(function(resolve,reject){
        resolve(5);
    });

    p.then(function(data){
        console.log(data);
    })

    虽然promise解决了异步编程的问题，但是在then的外面还是异步的

    没有promise也能进行开发，只不过维护起来麻烦点

    then中包含2个函数，第二个函数是成功之后的回调，第二个函数是失败之后的回调

    finally：不管成功还是失败都会进行的回调函数

    如果代码有可能会报错，下面的代码是不会执行的，如果使用try，catch那么try中的代码报错会进catch，报错是不会影响后面代码执行的
    try{
        
    }catch(e){

    }

    // 第一个then的返回值，是第二个then的参数 ....
    fetch().then(function(d){
        return d.json();
    }).then(function(d){
        console.log(d);// d就是d.json()
    });

    当进第一个then的时候，d就是返回的数据，但是这个数据是被promise包了一层
    d.json() -> '[]'->[]

    JSON -> 长得像对象和数组的字符串，本质是字符串

    parse必须为标准的JSON格式才成功转换
    '{"name":"zf"}'
    '[]' -> []

    对象转JSON -> JSON.stringify() 副作用是函数和undefined会被过滤掉
    [] -> '[]'

    

```
