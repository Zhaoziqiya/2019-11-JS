## var、let、const

- var：当通过var创建一个变量的时候，会进行预解析（变量提升）

        因为var会预解析，所以变量会当作属性存到全局的活动变量对象下（window下）
        不支持块级作用域
        不会主动村每次循环的值

- let：当通过let创建一个变量的时候，不会进行预解析（不会变量提升）

        在定义变量之前访问这个变量，之前访问的空间叫暂存死区
        支持块级作用域
        会把每次循环的值储存起来
        不能声明同名的变量、函数、参数


> 块{}：在块套块中，子块有函数，如果在父块或者在父块上访问这个函数，那么就是undefined`如果在子块的下方访问这个函数，就能找到这个函数`



- const：常量（不可变的量）
        当声明一个变量，不允许改变的时候就使用const定义
        不能声明一个同名的变量、函数、参数
        注意：
            `const赋值的数据，它只会监控这个数据的地址`

js是一个弱类型语言

## 单例模式

- 单例模式：

    单例：单独的实例
    实例：描述具体的事物
    构造函数：抽象一个类的封装过程


- 高级单例模式：
    - 让当前这个实例功能更加强大，还可以隐藏或者暴露细节信息

        高级单例模式你需要知道哪些东西？

            1.为什么要用高级单例模式？
                让当前这个实例功能更加强大，还可以隐藏或者暴露内部细节信息

                解决了命名冲突的问题

            2.高级单例模式如何写?
                (function(){

                    return {

                    }
                })()
            最后让一个变量去收这个功能强大的对象

        解决命名冲突的问题:

            1.封闭空间  （把变量或者函数放到函数中）
                let a = 10;
                (function(){
                    let a =20;
                })()

            2.命名空间
                // let name = 10;
                obj.name
                // let name = 20;
                obj2.name

    - 原始值:字符串，数字，布尔值...
    - 引用类型(里面让着很多的原始值和引用值)


## 工厂模式

- 工厂模式：为了批量生产实例





## 面向对象

- 面向对象：是一个计算机发展到一定阶段后的产物，是一种现实世界理解和抽象的方法。

    JS是基于面向对象思想构建出来的编程语言

    抽象：抽出像的部分（把相同的代码抽离出来）

    类  class

    **换了一种写法**

    为什么要用面向对象来编程？

        通过对象来编程，扩展性更强，能够做到高内聚、低耦合

    **面向对象：`
       将具有相同特征，特性的代码抽离出来归为一类，然后把描述这个类的细节特性（属性、方法）挂在这个类的原型下的一种编程方式。`**

    构造函数（类）  类别、模糊性 constructor

    `首字母大写`

        老师：给我讲东西的老师

    实例    唯一的、具体的

        我：你真胖

    `对象是Object构造出来的`

- new 是函数一元运算符，专门运算函数的

    `使用new之后会调用函数，就算不加()也会调用函数`

    创建方式：**{}、object、new 函数**

    使用new之后this就变成了实例（实例就是一个对象）`函数对象`也是**空白对象**

    使用new之后，函数默认返回值为实例化对象，**不是undefined**

    > 如果return后面为简单类型返回值为对象（实例）

    > return后面为引用类型返回值为return的引用类型


- 原型对象
    
    在js中，所有的class（类）都是函数模拟出来的

    当声明一个函数的时候，这个函数自身有一些属性或者方法（天生自带的）

    其中有一个属性叫做prototype，它的**值为对象**

    这个prototype就是原型，也就是说函数身上才有原型（其他都为undefined）

    **函数的原型下的属性或者方法只给它`（构造函数）`的实例化对象使用。**


- 原型链：
    - __ proto__ 实例化对象下都有 __ proto__
    这个属性全等于实例的构造函数的原型

### 理解含义
- `实例有原型链，函数有原型，原型又是一个对象，对象它就是实例
        实例又有原型链，找到构造函数的原型，Object.prototype.__proto__ = null`


